## 单表访问的方法

#### 访问方法（（**access method**））的概念

查询执行方式：

+ 使用全表扫描进行查询
+ 使用索引进行查询 
  + 针对主键或唯一索引的等值查询
  + 针对普通耳机索引的等值查询
  + 针对索引列的范围查找
  + 直接扫描整个索引

##### const

通过主键或者唯一二级索引列来定位一条记录的访问方法定义为：const

##### ref

普通的二级索引列与常数进行等值比较

##### ref_of_null

不仅想找出某个二级索引列的值等于某个常数的记录，还想把该列的值为NULL的记录也找出来，就像下边这个查询：

```
SELECT * FROM single_demo WHERE key1 = 'abc' OR key1 IS NULL;
```

##### range

是索引列需要匹配某个或某些范围的值，在本查询中key2列的值只要匹 配下列3个范围中的任何一个就算是匹配成功了

##### index

```
SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc'; 
```

它的查询列表只有3个列：key_part1, key_part2, key_part3，而索引idx_key_part又包含这三个列。 

搜索条件中只有key_part2列。这个列也包含在索引idx_key_part中。 

也就是说我们可以直接通过遍历idx_key_part索引的叶子节点的记录来比较key_part2 = 'abc'这个条件是否成立，把匹配成功的二级索引记 

录的key_part1, key_part2, key_part3列的值直接加到结果集中就行了。由于二级索引记录比聚簇索记录小的多（聚簇索引记录要存储所有用 

户定义的列以及所谓的隐藏列，而二级索引记录只需要存放索引列和主键），而且这个过程也不用进行回表操作，所以直接遍历二级索引比直 

接遍历聚簇索引的成本要小很多，设计MySQL的大叔就把这种采用遍历二级索引记录的执行方式称之为：index。

**all** 

最直接的查询执行方式就是我们已经提了无数遍的全表扫描，对于InnoDB表来说也就是直接扫描聚簇索引，设计MySQL的大叔把这种使用全表 

扫描执行查询的方式称之为：all。 



#### 索引合并

#### **Intersection**合并

读取多个二级索引比读取一个二级索引消耗性能，但是读取二级索引的操作是顺序I/O，而回表操作是随机I/O，所以如果只读取一个二级 

索引时需要回表的记录数特别多，而读取多个二级索引之后取交集的记录数非常少，当节省的因为回表而造成的性能损耗比访问多个二级索引 带来的性能损耗更高时，读取多个二级索引后取交集比只读取一个二级索引的成本更低

#### union合并

```
SELECT * FROM single_table WHERE key1 = 'a' OR key3 = 'b' 
```

+ 二级索引列是等值匹配的情况
+ 主键列可以是范围匹配
+ 使用Intersection索引合并的搜索条件

#### **Sort-Union**合并

```sql
SELECT * FROM single_table WHERE key1 < 'a' OR key3 > 'z'
```



先根据key1 < 'a'条件从idx_key1二级索引总获取记录，并按照记录的主键值进行排序 

再根据key3 > 'z'条件从idx_key3二级索引总获取记录，并按照记录的主键值进行排序 

因为上述的两个二级索引主键值都是排好序的，剩下的操作和Union索引合并方式就一样了。