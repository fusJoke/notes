# 数据目录

数据目录用来存储mysql运行过程中产生的数据。

```
 SHOW VARIABLES LIKE 'datadir';
```

新建一个数据库时，

+ 在数据目录下创建一个和数据库名同名的子目录
+ 在该与数据库名同名的子目录下创建一个名为db.opt的文件，这个文件中包含了该数据库的各种属性

新建一个表：

+ 对应的子目录下就会创建一个名为test.frm的用于描述表结构的文件。这个后缀名为.frm是以二进制格式存储的

### 表空间

#### 系统表空间

默认情况下，InnoDB会在数据目录下创建一个名为ibdata1的文件，12M,可以自扩展

#### 独立表空间

MySQL5.6.6InnoDB并不会默认的把各个表的数据存储到系统表空间中，而是为每一个表建立一个独立表空间。独立表空间来存储表数据，会在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同，只不过添加了一个.ibd的扩展名



##### 文件系统对数据库的影响

+ 数据库名称和表名称不得超过文件系统所允许的最大长度
+ 特殊字符的问题
+ 文件长度受文件系统最大长度限制



### innodb表空间

一个独立表空间里面的数据页过多，对页进行分区管理，连续的64个页称为一个区。每256个区称为一个组

![image-20211201221900579](image-20211201221900579-8368342.png)

前三个组是固定的：

+ 第一个组最开始的3个页面的类型是固定的，也就是说extent 0这个区最开始的3个页面的类型是固定的，分别是

  + FSP_HDR类型： 这个类型的页面是用来登记整个表空间的一些整体属性以及本组所有的区
  + IBUF_BITMAP类型： 这个类型的页面是存储本组所有的区的所有页面关于INSERT BUFFER的信息
  + INODE类型：这个类型的页面存储了许多称为INODE的数据结构

+ 其余各组最开始的2个页面的类型是固定的，也就是说extent 256、extent 512这些区最开始的2个页面的类型是固定的，分别是：

  + XDES类型：全称是extent descriptor，用来登记本组256个区的属性
  + IBUF_BITMAP类型

  

段的概念

​	叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段（segment），存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。

默认情况下一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M存储空间，所以默认情况下一个只存了几条记录的小表也需要2M的存储空间么？这个问题的症结 ，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面 也不能挪作他用。现在为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，设计InnoDB的大叔们提出了一个碎片（fragment）区的概念，也就是在一个碎片区中，并 

不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何 

一个段。所以此后为某个段分配存储空间的策略是这样的： 

在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的。 

当某个段已经占用了32个碎片区页面之后，就会以完整的区为单位来分配存储空间。 



#### 区的分类

+ 空闲的区：现在还没有用到这个区中的任何页面。 

+ 有剩余空间的碎片区：表示碎片区中还有可用的页面。 

+ 没有剩余空间的碎片区：表示碎片区中的所有页面都被使用，没有空闲页面。 

+ 附属于某个段的区。每一个索引都可以分为叶子节点段和非叶子节点段，除此之外InnoDB还会另外定义一些特殊作用的段，在这些段中的数据量很大时将使用区来作为基本的分配单位。

为XDES Entry的结构（全称就是Extent Descriptor Entry），每一个区都对应着一个XDES Entry结构，这个结构记录了对应的区的一些属性

![image-20211201225531656](image-20211201225531656-8370533.png)



