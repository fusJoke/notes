#### count(*)为什么这么慢

1. count(*)实现方式

   - MyISAM把一个表的总行数存在磁盘上，直接返回行数
   - InnoDB引擎，逐条读出，然后累积计数

2. InnoDB为什么不把数字存起来

   InnoDB的默认级别是可重复读，通过多版本并发控制(mvcc)来实现。每一行都要判读对当前事务是否是可见的。所以只能逐条读取依次判断，可见的行才能进入计数。
   主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。普通索引树比主键树小得多。mysql优化器总是找最小的树来遍历

3. show table status
   这个命令的输出结果里面也有一个 TABLE_ROWS 用于显示这个表当前有多少行。但是这个结果是采样估算，官方文档说误差可能达到 40% 到 50%。

4. 计数方式小结
   MyISAM 表虽然 count(*) 很快，但是不支持事务；*
   show table status 命令虽然返回很快，但是不准确；
   InnoDB 表直接 count(*) 会遍历全表，虽然结果准确，但会导致性能问题。

5. 缓存系统保存计数的问题

   - 缓存丢失更新。数据新增一条时，缓存异常重启了，从而丢失计数。解决数据库计数后，重写写入缓存。
   - 逻辑上不精确。事务A和事务B，事务A做加入数据并更新缓存。事务B读取数据。并发的情况下，可能导致读取到旧数据，然而计数是最新的。导致不一致

6. 在数据库保存计数的优势

   - 解决了崩溃丢失的问题，InnoDB 是支持崩溃恢复不丢数据的
   - 事务特性解决逻辑上不准确。计数和查找的数据都是一致

7. count(*)、count(主键 id)、count(字段) 和 count(1)的性能区别

   - count(param)的语义。对于返回结果集，一行行的判断，param不为null计数+1
   - count(id)，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加
   - 对于count(1), InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加
   - count(字段)，如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。
   - count(*) 是例外，MySQL 专门针对这个语句进行优化。
   - count(字段)<count(主键 id)<count(1)≈count(`*`)，所以我建议你，尽量使用 count(*)