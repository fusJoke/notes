
线程

1. 要保持线程的上下文状态，保持寄存器状态，调用syscall进入操作系统内核，选择一个线程进行切换，可能会涉及页的中断，内存置换
2. 阻塞的时候进行切换



协程

1. 在某个时刻，一个线程只能跑一个线程；如果一个协程阻塞，同一个线程上协程也会进入阻塞。
2. 开启一个线程需要8k的逻辑内存；协程则要小得多，goroutine则是1k

3. 协程的切换也是栈、寄存器的切换；但是切换的寄存器的数量比较少。



go的goroutine是线程和协程的混合

1. 每个cpu上面都绑定一个线程，叫machine，简写M

2. 将阻塞的系统调用改成non-block版本(read-no-block, sleep,等)

   + 没有阻塞就继续执行
   + 阻塞，切换到另一个协程进行执行。

3. 生产者-消费者解决大部分的问题，提供一个api不就解决了吗？

   channel
   
   

## 基本概念

1. 进程是应用程序的实例，每个进程有独立的内存空间，不同进程通过进程间的通信方式来通信

2. 线程从属于进程，每个进程都至少包含一个线程，线程是cpu调度的基本单位。

3. 协程是用户态的线程，调度不受操作系统控制，协程调度由用户应用程序提供。共享用户线程的cpu时间片。

4. 线程池

   频繁的创建和销毁线程，会带来不必要的开销。线程池技术可以解决这样的问题，预先在线程池中保存一定数量的线程，新任务不在以创建线程的方式去执行，而是将任务发布到任务队列，线程池不断地从任务队列中取出任务进行执行。

   过多线程会导致上下文切换的开销变大。协程调度器把可运行的协程逐个调度到线程中去执行，同时及时把阻塞的协程调度出线程，减少线程的频繁切换。



## 调度模型

1. 线程模型
   + N:1,一个用户线程运行在一个内核线程中
   + 1:1,一个用户线程对应一个内核线程
   + M:N，M个线程运行在N内核线程
2. go协程调度模型
   + M(machine): 工作线程，它由操作系统调度
   + P(processor): 处理器，包含go代码的必要资源，也有调度goroutine的能力
   + G(goroutine): 即go协程，每个go关键字都会创建一个协程

GM模型的缺点：

+ 为了确保一个线程只能拿到一个g，加一个全局锁。全局锁的问题，g相关的操作都要加上锁。锁竞争非常激烈。
+ 工作者线程（M's）之间会经常交接可运行的 goroutine。
+ 每个 M 必须能够执行任何可运行的 G，特别是刚刚创建 G 的 M。每个 M 都需要做内存缓存（M.mcache)



引入P之后为什么可以解决这些问题？

p其实就是一个队列，负责衔接G和M

1. 每个P都有自己的本地队列，本地队列不需要加锁，减少了锁竞争
2. 每个P相对平衡，在 GMP 模型中也实现了 Work Stealing 算法，如果 P 的本地队列为空，则会从全局队列或其他 P 的本地队列中窃取可运行的 G 来运行，减少空转，提高了资源利用率



为什么不给M一个本地队列，而是另外抽出一个抽象的P概念

		1. M会阻塞。
		2. M挂一个本地队列的话，本地队列也要随着M新增和销毁而新增和销毁。



### work-stealing算法



### 什么是g0

g的分类：

+ 执行用户任务的叫做 g
+ 执行 `runtime.main` 的 main goroutine
+ 执行调度任务的叫 g0

每个M都会分配有一个g0，

g0负责创建goroutine

垃圾回收

defer函数



### 什么是m0

m0 是 Go Runtime 所创建的第一个系统线程，一个 Go 进程只有一个 m0，也叫主线程。

从多个方面来看：

- 数据结构：m0 和其他创建的 m 没有任何区别。
- 创建过程：m0 是进程在启动时应该汇编直接复制给 m0 的，其他后续的 m 则都是 Go Runtime 内自行创建的。
- 变量声明：m0 和常规 m 一样，m0 的定义就是 `var m0 m`，没什么特别之处。





