go使用的三色标记法就是属于追踪式垃圾回收(另外一种，引用计数)。

用户程序（Mutator）会通过
		内存分配器（Allocator）在堆上申请内存
		垃圾收集器（Collector）负责回收堆上的内存空间

什么是STW
		STW, stop the world GC 的一些阶段需要停止所有的 mutator 以确定当前的引用关系

什么是Root
		根对象，应用程序可直接访问的，例全局变量，栈对象中的数据

mark 和 sweep阶段
		标记(Mark)和 清除(Sweep)

通过白色(white),  灰色(grey), 黑色(black) 三色标记对象

+ 白色(white)，可能是垃圾要回收
+  黑色(black)，活跃的对象且没有引用其他外部指针
+ 灰色(grey)，活跃的对象但有引用其他外部指针，垃圾收集器会扫描它的子对象



强三色不变性：黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象

弱三色不变性 ：黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径


写屏障

如果在sweep阶段时，一个白色对象被一个黑色对象和几个灰色对象引用，所有灰色对象取消对白色对象引用，就造成白色对象被错误回收。可以通过写屏障机制，白色对象在被黑色对象引用的时候强制标灰。缺点就是如果在栈内存使用写屏障会导致性能下降非常大 

删除屏障

在灰色对象指向白色对象指针被删除的时候，将白色对象变灰。如果黑色对象对白色对象的指针也被取消了，也不会在本轮gc被回收。回收精度低



插入屏障和删除屏障各有优缺点，Dijkstra 的插入写屏障在标记开始时无需 STW，可直接开始，并发进行，但结束时需要 STW 来重新扫描栈，标记栈上引用的白色对象的存活；Yuasa 的删除写屏障则需要在 GC 开始时 STW 扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象，但结束时无需 STW



而go使用的是混合屏障，Golang 中的混合写屏障满足的是变形的弱三色不变式，同样允许黑色对象引用白色对象，白色对象处于灰色保护状态，但是只由堆上的灰色对象保护

1.GC开始时，将栈上对象都设置为黑色

2.GC期间，任何栈上面的新增的对象都是黑色

3.堆内存使用混合写屏障



