### 1.秒杀场景特征

+ **瞬间并发访问量高**

  数据库每秒只能支撑千级别的并发请求，redis则能达到万级别

  当有大量并发请求涌入秒杀系统时，我们就需要使用Redis先拦截大部分请求，避免大量请求直接发送给数据库，把数据库压垮

+ **读多写少，读操作是简单的查询操作**

  在秒杀场景下，用户需要先查验商品是否还有库存。秒杀活动中只有少部分用户能成功下单，所以，商品库存查询操作（读操作）要远多于库存扣减和下单操作（写操作）

  

### 2.Redis可以在秒杀场景的哪些环节发挥作用？

##### 2.1.第一阶段是秒杀活动前

用户会不断刷新商品详情页，这会导致详情页的瞬时请求量剧增。

这个阶段的应对方案，一般是尽量**把商品详情页的页面元素静态化，然后使用CDN或是浏览器把这些静态化的元素缓存起来**。这样一来，秒杀前的大量请求可以直接由CDN或是浏览器缓存服务，不会到达服务器端了，这就减轻了服务器端的压力

##### 2.2.第二阶段是秒杀活动开始

这个阶段三个操作：**库存查验**、**库存扣减**和**订单处理**。

Redis保存库存量，请求可直接从Redis中读取库存并进行查验。

##### 为什么不在数据库执行库存的扣减。

1.额外的开销。Redis中保存了库存量，而库存量的最新值又是数据库在维护，所以数据库更新后，还需要和Redis进行同步，这个过程增加了额外的操作逻辑，也带来了额外的开销。

2.**下单量超过实际库存量，出现超售**。数据库的处理速度较慢，不能及时更新库存余量，这就会导致大量库存查验的请求读取到旧的库存值

总结：所以在redis中进行库存扣减

##### 2.3.第三阶段是秒杀结束

还会有部分用户刷新商品详情页，尝试等待有其他用户退单。而已经成功下单的用户会刷新订单详情，跟踪订单的进展



#### 4.Redis的哪些方法可以支撑秒杀场景？

**支持高并发**。多个秒杀商品可以使用切片集群，用不同的实例保存不同商品的库存，这样就避免，使用单个实例导致所有的秒杀请求都集中在一个实例上的问题了

**保证库存查验和库存扣减原子性执行**。可用Redis的原子操作或是分布式锁这两个功能特性来支撑

##### 基于原子操作支撑秒杀场景

用hash类型的键值对保存库存信息

```
key: itemID
value: {total: N, ordered: M}
itemID是商品的编号，total是总库存量，ordered是已秒杀量
```

**一个直接的方法就是使用Redis的原子操作**



#### 基于分布式锁来支撑秒杀场景

**先让客户端向Redis申请分布式锁，只有拿到锁的客户端才能执行库存查验和库存扣减**。秒杀请求就会在争夺分布式锁时被过滤掉

```
//使用商品ID作为key
key = itemID
//使用客户端唯一标识作为value
val = clientUniqueID
//申请分布式锁，Timeout是超时时间
lock =acquireLock(key, val, Timeout)
//当拿到锁后，才能进行库存查验和扣减
if(lock == True) {
   //库存查验和扣减
   availStock = DECR(key, k)
   //库存已经扣减完了，释放锁，返回秒杀失败
   if (availStock < 0) {
      releaseLock(key, val)
      return error
   }
   //库存扣减成功，释放锁
   else{
     releaseLock(key, val)
     //订单处理
   }
}
//没有拿到锁，直接返回
else
   return
```





