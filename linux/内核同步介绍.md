## 内核同步介绍

### 1.临界区和竞争条件

​	所谓临界区（临界段）就是访问和操作共享数据的代码段。多个执行线程并发访问同一个资源通常是不安全的，为了避免在临界区中并发访问，编程者必须保证这个代码原子地执行--操作在执行结束前不可被打断。

# 内核同步方法

### 1.原子操作

原子操作可以保证指令以原子的方式执行--执行的过程不被打断。原子操作也称不能够分割指令。

#### 1.1 原子整数操作

​		针对整数的原子操作只能对atomic_t类型的数据进行处理。原子函数只接收atomic_t类型的操作数，确保原子操作只和这种特殊的数据类型进行一起使用。同时也保证了该数据类型不会被传递给任何非原子函数。这点使得原子操作最终接受到正确的内存地址。
​		

```
typedef struct{
		volatile int counter;
}atomic_t;
```

定义一个atomic_t类型的数据方法很平常，

```
atomic_t v; 
atomic_t u=ATOMIC_INIT(0);
```

原子操作通常是内联函数，往往通过内联汇编指令来实现的。

#### 原子性与顺序性的比较

一个字长的读取总是原子地发生，绝不可能对一个字交错地进行写。读总是发生返回一个完整的字。

#### 1.1.2 64位原子操作

atomic64_t类型--其功能和32位atomic_32位没什么区别。

#### 1.1.3 原子位操作

内核也提供针对位这一个级别进行操作的函数。位操作函数是对普通内存地址进行操作的。他的参数是一个指针和一个位号，第0位是给定地址的最低有效位。

### 1.2 自旋锁

自旋锁最多只能被一个可执行的线程拥有。如果一个执行线程试图获得一个被已经持有自旋锁，那么线程就一直进行忙着循环--等待锁重新可用。自旋锁的初衷：在短期间内进行轻量级加锁。还可采用另外的方式来处理对锁的争用:让线程睡眠，知道锁可用时重新唤醒。

#### 1.2.1 自旋锁方法

​		同一个时刻，只能由一个线程位于临界区内。linux内核实现的自旋锁是不可递归。自旋锁可以使用在中断处理中。在中断程序使用自旋锁的时候，一定要在获得锁之前，首先禁止本地中断，中断程序可能打断了持有了自旋锁的内核代码，然后又去请求这个自旋锁。

​		内核提供了中断自旋请求的接口

```
DEFINE_SPINLOCK(mr_lock);
unsigned long flags;
spin_lock_irqsave(&mr_lock, flags);
spin_unlock_irqsave(&mr_lock, flags);
```

spin_lock_irqsave()保存中断的当前状态，并禁止本地中断。然后再去获取指定的锁。反过来spin_unlock_irqrestore()对指定的锁解锁，然后让中断恢复到加锁前的状态。

##### 锁是什么？

​		要知道需要保护的是数据而不是代码。需要保护的是临界区的数据。
​		大原则：针对代码加锁会是的程序难以理解，并且容易引进竞争条件，正确做法应该是对数据加锁而不是对代码加锁

#### 1.2.2 其他针对自旋锁的操作

​		spin_try_lock()试图获得某个特定的自旋锁。如果该锁被争用了，那么该方法就立刻返回一个非零值。
​		spin_is_locked()检查是否被占用。

#### 1.2.3 自旋锁和下半部

​		spin_lock_bh()用于获得指定锁，同时会禁止所有的下半部的执行。由于下半部和进程下半部共享数据时，必须对进程的上下文的共享数据进行保护，所以需要加锁的同时还要禁止下半部的执行。同样的中断处理程序可以抢占下半部，所以如果中断处理程序和下半部共享数据，获取恰当的锁的同时还要禁止中断。同类的tasklet不可能同时运行，所以同类的tasklet中的共享数据不需要保护。但是当数据被两个不同种类的tasklet共享时，就需要在访问下半部中的数据前先获得一个普通的自旋锁。这里不需要机制下半部，因为在同一个处理器上面绝不会tasklet互相抢占的情况。
​		对于软中断，无论是不是同种中断，数据都需要得到锁的保护。

#### 1.3 读-写自旋锁

​	锁可以明确的分为读取和写入两个情景。对数据既要检索又要更新。当更新数据是，不能有其他的代码并发地写数据或读取数据，写操作要求完全互斥。
​	对某个数据结构的操作可以像这样被划分为读/写或者消费者/生产者的两种类别。linux内核提供了专门读-写自旋锁。一个或多个任务可以并发地持有读者锁；相反，用于写的锁最多只能被一个写任务持有，此时不能并发的读操作。有时把读/写锁。	

​	读/写锁自旋锁的使用类似于普通自旋锁

```c
DEFINE_RWLOCK(mr_rwlock);
```

```c
read_lock(&mr_rwlock);
read_unlock(&mr_rwlock);
```

不能把一个读锁升级成一个写锁。

### 1.4 信号量

linux中的信号量是一种睡眠锁。如果有一个任务试图获得一个不可用（已经被占用的）信号量时，信号量会将其推进一个等待队列，让其睡眠。这时候处理器能重获自由，从而去执行其他代码。当持有得信号量可用后，处于等待队列中的那个任务被唤醒，并获得该信号量

+ 由于争用信号量的进程在等待锁变为可用的时会睡眠，所以信号量适用于锁会被长时间持有得情况
+ 相反，锁被短时间持有时，使用信号量就不太合适。因为睡眠、维护等待队列以及唤醒所花费的开销可能比锁被占用的全部时间还要长。
+ 由于执行线程在锁被争用的时候会睡眠，所以只能在进程上下文中才能获得锁，因为在中断上下文中是不能进行调度的
+ 你可以有持有信号量是取睡眠，因为当其他进程试图获得同一信号量时不会因此而死锁。
+ 在占用信号量的同事不能占用自旋锁。因为你在等待信号量时可能会睡眠，而在持有自旋锁是不允许睡眠的。

#### 1.4.1 计数信号量和二值信号量

​		信号量允许同时任意数量的锁持有者，而自旋锁在一个时刻最多允许一个任务持有它。信号量同时允许的持有者数量可以在声明信号量时指定，简单叫数量。计数等于1的信号量，叫二值信号量，又叫互斥信号量。大于1的非零值的信号量叫计数信号量。
​		信号量支持两个原子操作P()和V()。后来系统把两种操作分别叫做down()和up()。down通过对信号量计数减1来请求获得一个信号量。如果大于0就是获得锁，任务就可以进入临界区。如果是负数就会被放入等待队列，处理器处理其他任务。通过up来提升一个信号量计数，如果在该信号量上的等待队列不为空，那么处于队列中的等待任务就会被唤醒同时会获得该信号量。

#### 1.4.2 创建和初始化信号量

```c
struct semaphore name;
sema_init(&name, count);
```

创建更为普通的互斥信号量可以使用

```c
static_DECLARE_MUTEX(name);
```

信号量作为一个大数据结构的一部分动态创建。

```c
sema_init(sem, count)
```

#### 1.4.3 使用信号量

函数down_interruptible() 试图获取指定的信号量，如果信号量不可用，它将调用进程设置为TASK_INTERRUPTIBLE状态--进入睡眠。

### 1.5  读-写信号量

与自旋锁一样，信号量也有区分读-写访问的可能。

```c
//rw-semaphore结构表示
static DECLARE_RWSEM(name);
//动态创建
init_rwsem(struct rw_semaphore *sem);
```

读-写信号量都是互斥信号量，引用计数都是1。

### 1.6 互斥体

​		互斥体是任何可以睡眠的互斥锁，计数1的信号量就是其中之一。
​		DEFINE_MUTEX(name)
​		动态初始化mutex，你需要做：
​		mutex_init(&mutex)；
​		对互斥锁锁定和解锁并不难：
​		mutex_lock(&mutex);
​		mutex_unlock(&mutex);

+ 任何时刻中只有一个任务可以持有mutex
+ 给mutex上锁者必须负责给其再解锁，同一上下文环境上锁和解锁
+ 递归地上锁和解锁是不允许的。
+ 当持有一个mutex时，进程不可以退出
+ mutex不能再中断或者下半部中使用，mutex_trylock()
+ Mutex只能通过官方api管理：

#### 1.6 自旋锁和互斥体

| 需求           | 建议加锁的方法 |
| -------------- | -------------- |
| 低开销加锁     | 优先使用自旋锁 |
| 短期锁定       | 优先使用自旋锁 |
| 长期加锁       | 互斥体         |
| 中断上下文加锁 | 使用自旋锁     |
| 持有锁需要睡眠 | 使用互斥体     |

#### 1.7 完成变量

​		一个任务需要发出信号通知另一个任务发生特定的事件，是使两个任务得以同步的简单方法。如果一个任务要执行一些工作时，另一个任务就在完成变量上等待。当这个任务完成工作后，会使用完成变量去唤醒在等待的任务。

​		完成变量由结构completion表示:

```c
DECLARE_COMPLETION(MR_COMP)
```

​		通过ini_completion动态创建并初始化完成变量。在一个指定的完成变量上，需要等待的任务调用wait_for_completion()来等待特定时间。当特定事件发生后，产生时间的任务调用complete()来发送信号唤醒正在等待的任务。

### 1.8  BKL：大内核锁

大内核锁是一个全局自旋锁。

### 1.9 顺序锁：seq锁

​		用于读写共享数据。实现这种锁主要依靠一个序列计数器。当有疑义的数据被写入时，会得到一个锁，并且序列值会增加。在读取数据之前和之后，序列号都被读取。如果读取序列号值相同，说明在读操作进行的过程中没有被写操作打断写。锁的初值为0， 写锁会使值变成奇数，释放的时候变成偶数

​	定义一个seq锁

```c
seqlock_t mr_seq_lock = DEFINE_SEQLOCK(mr_seq_lock);

write_seqlock(&mr_seq_lock);
write_sequnlock(&mr_seq_lock);

unsigned long seq;
do{
  	seq = read_seqbegin(&mr_seq_lock);
}while(read_seqretry(&mr_seq_lock, seq));
```

#### 1.10 禁止抢占

由于内核是抢占性的，内核中的进程在任何时刻都可能停下来以便另一个具有更高优先权的进程运行。如果一个自旋锁被持有，内核便不能进行抢占。

| 函数                        | 描述                                                         |
| --------------------------- | ------------------------------------------------------------ |
| preempt_disable()           | 增加抢占计数值，从而禁止内核抢占                             |
| preempt_enable()            | 减少抢占计数，并当该值降为零时检查和执行被挂起的需调度的任务 |
| Preempt_enable_no_resched() | 激活内核抢占但不再检查任何被挂起的调度任务                   |
| preempt_count()             | 返回抢占计数。                                               |

#### 1.11 顺序的屏障

当处理多处理器之间或硬件设备之间的同步问题时，有时需要在你的程序代码中以指定的顺序发出读内存和写内存指令。
