## 不可靠的网络

互联网和数据中心（通常是以太网）中的大多数内部网络都是 **异步分组网络（asynchronous packet networks）**。

一节点向另一节点发送消息，不能确定何时到达或是否到达。因为很多事情可能会出错：

+ 请求丢失
+ 请求在排队，会延迟到达
+ 远程节点失效
+ 远程节点暂时暂停响应，但稍后会再次响应
+ 远程节点可能已经处理了请求，但是网络上的响应已经丢失
+ 远程节点可能已经处理了请求，但是响应已经被延迟，并且稍后将被传递

处理这个问题的通常方法是 **超时（Timeout）**：在一段时间之后放弃等待，并且认为响应不会到达。

#### 检测故障

系统需要自动检测故障节点：

- 负载平衡器需要停止向已死亡的节点转发请求（从轮询列表移出，即 out of rotation）。
- 在单主复制功能的分布式数据库中，如果主库失效，则需要将从库之一升级为新主库。

不幸的是，网络的不确定性使得很难判断一个节点是否工作。在某些特定的情况下，你可能会收到一些反馈信息，明确告诉你某些事情没有成功：

+ 如果你可以连接到节点，但没有进程正在监听目标端口，操作系统将通过发送 FIN 或 RST 来关闭并重用 TCP 连接。但是，如果节点在处理请求时发生崩溃，则无法知道远程节点实际处理了多少数据。
+ 如果节点进程崩溃，，但节点的操作系统仍在运行，则脚本可以通知其他节点有关该崩溃的信息，以便另一个节点可以快速接管，而无需等待超时到期
+ 如果你有权访问数据中心网络交换机的管理界面，则可以通过它们检测硬件级别的链路故障
+ 如果路由器确认你尝试连接的 IP 地址不可用，则可能会使用 ICMP 目标不可达数据包回复你

#### 超时与无穷的延迟

超时是检测故障的唯一可靠方法，那么超时应该等待多久？不幸的是没有简单的答案

长时间的超时意味着长时间等待，直到一个节点被宣告死亡。短的超时可以更快地检测到故障，但有更高地风险误将一个节点宣布为失效。

当一个节点被判定为死亡，需要其他节点顶替这个节点的职能，这会给其他节点和网络带来额外的负担。这时将其负载转移到其他节点可能会导致 **级联失效**

#### 网络拥塞和排队

计算机网络上数据包延迟的可变性通常是由于排队：

+ 多个不同的节点向同一个节点发包，则网络交换机必须将它们排队然后逐个送入目标网络链路。传入的数据太多，交换机队列填满，数据包将被丢弃，因此需要重新发送数据包 - 即使网络运行良好
+ 当数据包到达目标机器时，如果所有 CPU 内核当前都处于繁忙状态，则来自网络的传入请求将被操作系统排队，直到应用程序准备好处理它为止
+ 在虚拟化环境中，正在运行的操作系统经常暂停几十毫秒，因为另一个虚拟机正在使用 CPU 内核。在这段时间内，虚拟机不能从网络中消耗任何数据，所以传入的数据被虚拟机监视器 【26】排队（缓冲），进一步增加了网络延迟的可变性。
+ TCP 执行 **流量控制**（flow control，也称为 **拥塞避免**，即 congestion avoidance，或 **背压**，即 backpressure），其中节点会限制自己的发送速率以避免网络链路或接收节点过载

## 不可靠的时钟

时钟和时间很重要。应用程序以各种方式依赖于时钟来回答以下问题：

1. 请求是否超时？
2. 这项服务的第99百分位响应时间是多少？
3. 在过去五分钟内，该服务平均每秒处理多少个查询？
4. 何时发送时间？
5. 缓存条目何时到期？
6. 日志文件中此错误消息的时间戳是什么？

**网络时间协议（NTP）**，它允许根据一组服务器报告的时间来调整计算机时钟

#### 单调钟与日历时钟

现代计算机至少有两种不同的时钟：日历时钟（time-of-day clock）和单调钟（monotonic clock）。

##### 日历时钟

它根据某个日历（也称为 **挂钟时间**，即 wall-clock time）返回当前日期和时间。日历时钟通常与 NTP 同步，这意味着来自一台机器的时间戳（理想情况下）与另一台机器上的时间戳相同

##### 单调钟

单调钟适用于测量持续时间（时间间隔）。

在具有多个 CPU 的服务器，每个 CPU 可能有一个单独的计时器，但不一定与其他 CPU 同步。操作系统会补偿所有的差异，并尝试向应用线程表现出单调钟的样子，即使这些线程被调度到不同的 CPU 上

如果 NTP 协议检测到计算机的本地石英钟比 NTP 服务器要更快或更慢，则可以调整单调钟向前走的频率（这称为 **偏移（skewing）** 时钟）。默认情况下，NTP 允许时钟速率增加或减慢最高至 0.05%，但 NTP 不能使单调时钟向前或向后跳转。单调时钟的分辨率通常相当好：在大多数系统中，它们能在几微秒或更短的时间内测量时间间隔。

#### 时钟同步与准确性

单调钟不需要同步，但是日历时钟需要根据 NTP 服务器或其他外部时间源来设置才能有用。

+ 计算机中的石英钟不够精确：它会 **漂移**。
+ 如果计算机的时钟与 NTP 服务器的时钟差别太大，可能会拒绝同步，或者本地时钟将被强制重置
+ 某个节点被 NTP 服务器的防火墙意外阻塞，有可能会持续一段时间都没有人会注意到
+ NTP 同步只能和网络延迟一样好，所以当你在拥有可变数据包延迟的拥塞网络上时，NTP 同步的准确性会受到限制
+ 闰秒导致一分钟可能有 59 秒或 61 秒，这会打破一些在设计之时未考虑闰秒的系统的时序假设
+ 在虚拟机中，硬件时钟被虚拟化，这对于需要精确计时的应用程序提出了额外的挑战

### 依赖同步时钟

##### 有序事件的时间戳

依赖时钟，在多个节点上对事件进行排序。例如，如果两个客户端写入分布式数据库，谁先到达？ 哪一个更近？

**逻辑时钟（logic clock）**【56,57】是基于递增计数器而不是振荡石英晶体，对于排序事件来说是更安全的选择

#### 全局快照的同步时钟

快照隔离最常见的实现需要单调递增的事务 ID。

### 进程暂停



### 真相由多数所定义

设想一个具有不对称故障的网络：一个节点能够接收发送给它的所有消息，但是来自该节点的任何传出消息被丢弃或延迟【19】。即使该节点运行良好，并且正在接收来自其他节点的请求，其他节点也无法听到其响应。经过一段时间后，其他节点宣布它已经死亡，因为他们没有听到节点的消息。



#### 领导者和锁

系统中唯一性的东西：

+ 数据库分区只有一个领导者，避免脑裂
+ 特定资源的锁或对象只允许一个事务 / 客户端持有，以防同时写入和损坏。
+ 一个特定的用户名只能被一个用户所注册，因为用户名必须唯一标识一个用户。

我们假设每次锁定服务器授予锁或租约时，它还会返回一个 **防护令牌（fencing token）**，这个数字在每次授予锁定时都会增加（例如，由锁定服务增加）。然后，我们可以要求客户端每次向存储服务发送写入请求时，都必须包含当前的防护令牌。

在 [图 8-5](https://github.com/Vonng/ddia/blob/master/img/fig8-5.png) 中，客户端 1 以 33 的令牌获得租约，但随后进入一个长时间的停顿并且租约到期。客户端 2 以 34 的令牌（该数字总是增加）获取租约，然后将其写入请求发送到存储服务，包括 34 的令牌。稍后，客户端 1 恢复生机并将其写入存储服务，包括其令牌值 33。但是，存储服务器会记住它已经处理了一个具有更高令牌编号（34）的写入，因此它会拒绝带有令牌 33 的请求。

如果将 ZooKeeper 用作锁定服务，则可将事务标识 `zxid` 或节点版本 `cversion` 用作防护令牌。由于它们保证单调递增，因此它们具有所需的属性

### 系统模型与现实

- 同步模型

  **同步模型（synchronous model）** 假设网络延迟、进程暂停和和时钟误差都是受限的。这并不意味着完全同步的时钟或零网络延迟；这只意味着你知道网络延迟、暂停和时钟漂移将永远不会超过某个固定的上限【88】。同步模型并不是大多数实际系统的现实模型，因为（如本章所讨论的）无限延迟和暂停确实会发生。

- 部分同步模型

  **部分同步（partial synchronous）** 意味着一个系统在大多数情况下像一个同步系统一样运行，但有时候会超出网络延迟，进程暂停和时钟漂移的界限【88】。这是很多系统的现实模型：大多数情况下，网络和进程表现良好，否则我们永远无法完成任何事情，但是我们必须承认，在任何时刻都存在时序假设偶然被破坏的事实。发生这种情况时，网络延迟、暂停和时钟错误可能会变得相当大。

- 异步模型

  在这个模型中，一个算法不允许对时序做任何假设 —— 事实上它甚至没有时钟（所以它不能使用超时）。一些算法被设计为可用于异步模型，但非常受限。

- 崩溃 - 停止故障

  在 **崩溃停止（crash-stop）** 模型中，算法可能会假设一个节点只能以一种方式失效，即通过崩溃。这意味着节点可能在任意时刻突然停止响应，此后该节点永远消失 —— 它永远不会回来。

- 崩溃 - 恢复故障

  我们假设节点可能会在任何时候崩溃，但也许会在未知的时间之后再次开始响应。在 **崩溃 - 恢复（crash-recovery）** 模型中，假设节点具有稳定的存储（即，非易失性磁盘存储）且会在崩溃中保留，而内存中的状态会丢失。

- 拜占庭（任意）故障

  节点可以做（绝对意义上的）任何事情，包括试图戏弄和欺骗其他节点，如上一节所述。

对于真实系统的建模，具有 **崩溃 - 恢复故障（crash-recovery）** 的 **部分同步模型（partial synchronous）** 通常是最有用的模型。