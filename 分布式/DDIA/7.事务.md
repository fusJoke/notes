## 什么是事务？

事务是应用程序将多个读写操作组合成一个逻辑单元的一种方式。事务中的所有读写操作被视作单个操作来执行：整个事务要么成功 **提交**（commit），要么失败 **中止**（abort）或 **回滚**（rollback）。如果失败，应用程序可以安全地重试。



## 事务的棘手

事务是可伸缩性的对立面，任何大型系统都必须放弃事务以保持良好的性能和高可用性。事实并非如此简单：与其他技术设计选择一样，事务有其优势和局限性

#### ACID

ACID 代表 **原子性（Atomicity）**，**一致性（Consistency）**，**隔离性（Isolation）** 和 **持久性（Durability）**。

（不符合 ACID 标准的系统有时被称为 BASE，它代表 **基本可用性（Basically Available）**，**软状态（Soft State）** 和 **最终一致性（Eventual consistency）**

##### 原子性

不可分割的操作。在多线程编程中，一个线程无法看到另一个线程的原子操作的中间结果。系统只能处于操作之前或操作之后的状态，而不是介于两者之间的状态。

如果事务被 **中止（abort）**，应用程序可以确定它没有改变任何东西，所以可以安全地重试。能够在错误时中止事务，丢弃该事务进行的所有写入变更的能力

##### 一致性

acid，对数据的一组特定约束必须始终成立。即 **不变式（invariants）**。一致性的这种概念取决于应用程序对不变式的理解，应用程序负责正确定义它的事务，并保持一致性。这并不是数据库可以保证的事情。原子性，隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。因此，字母 C 不属于 ACID

##### 隔离性

ACID 意义上的隔离性意味着，**同时执行的事务是相互隔离的**：它们不能相互冒犯。传统意义上的隔离性为 **可串行化（Serializability）**，这意味着每个事务可以假装它是唯一在整个数据库上运行的事务。数据库确保当多个事务被提交时，结果与它们串行运行（一个接一个）是一样的，尽管实际上它们可能是并发运行的

##### 持久性

是一个承诺，即一旦事务成功完成，即使发生硬件故障或数据库崩溃，写入的任何数据也不会丢失



### 单对象和多对象操作

数据库应该做的事情：

+ 原子性，如果在一系列写操作的中途发生错误，则应中止事务处理，并丢弃当前事务的所有写入
+ 隔离性，同时运行的事务不应该互相干扰

你想同时修改多个对象（行，文档，记录）。通常需要 **多对象事务（multi-object transaction）** 来保持多块数据同步。

多对象事务需要确定哪些读写操作属于同一个事务。在关系型数据库中，通常基于客户端与数据库服务器的 TCP 连接：在任何特定连接上，`BEGIN TRANSACTION` 和 `COMMIT` 语句之间的所有内容，被认为是同一事务的一部分

##### 单对象写入

这些问题非常让人头大，故存储引擎一个几乎普遍的目标是：对单节点上的单个对象（例如键值对）上提供原子性和隔离性。原子性可以通过使用日志来实现崩溃恢复，并且可以使用每个对象上的锁来实现隔离（每次只允许一个线程访问对象）

##### 多对象事务的需求

分布式数据存储已经放弃了多对象事务，因为多对象事务很难跨分区实现，而且在需要高可用性或高性能的情况下，它们可能会碍事。

##### 处理错误和中止

尽管重试一个中止的事务是一个简单而有效的错误处理机制，但它并不完美：

+ 如果事务实际上成功了，但是在服务器试图向客户端确认提交成功时网络发生故障
+ 如果错误是由于负载过大造成的，则重试事务将使问题变得更糟，而不是更好。为了避免这种正反馈循环，可以限制重试次数，使用指数退避算法，并单独处理与过载相关的错误
+ 仅在临时性错误（例如，由于死锁，异常情况，临时性网络中断和故障切换）后才值得重试。在发生永久性错误（例如，违反约束）之后重试是毫无意义的。
+ 如果事务在数据库之外也有副作用，即使事务被中止，也可能发生这些副作用



## 弱隔离级别

如果两个事务不触及相同的数据，它们可以安全地 **并行（parallel）** 运行。当一个事务读取由另一个事务同时修改的数据时，或者当两个事务试图同时修改相同的数据时，并发问题（竞争条件）才会出现。

数据库一直试图通过提供 **事务隔离（transaction isolation）** 来隐藏应用程序开发者的并发问题

### 读已提交

基本事务隔离是读已提交，它提供了两个保证：

1. 从数据库读时，只能看到已提交的数据（没有 **脏读**，即 dirty reads）。
2. 写入数据库时，只会覆盖已经写入的数据（没有 **脏写**，即 dirty writes）

##### 没有脏读

+ 如果事务需要更新多个对象，脏读取意味着另一个事务可能会只看到一部分更新
+ 如果事务中止，则所有写入操作都需要回滚。如果数据库允许脏读，那就意味着一个事务可能会看到稍后需要回滚的数据，即从未实际提交给数据库的数据。想想后果就让人头大。

##### 没有脏写

在 **读已提交** 的隔离级别上运行的事务必须防止脏写，通常是延迟第二次写入，直到第一次写入事务提交或中止为止。

##### 实现读已提交

最常见的情况是，数据库通过使用 **行锁（row-level lock）** 来防止脏写：当事务想要修改特定对象（行或文档）时，它必须首先获得该对象的锁。然后必须持有该锁直到事务被提交或中止。一次只有一个事务可持有任何给定对象的锁。对于写入的每个对象，数据库都会记住旧的已提交值，和由当前持有写入锁的事务设置的新值。当事务正在进行时，任何其他读取对象的事务都会拿到旧值。 只有当新值提交后，事务才会切换到读取新值。

##### 快照读和可重复读

**快照隔离（snapshot isolation）**是不可重复读最常见的解决方案。事务能看到事务开始时在数据库中提交的所有数据。即使这些数据随后被另一个事务更改，每个事务也只能看到该特定时间点的旧数据。

##### 实现快照隔离

快照隔离的一个关键原则是：**读不阻塞写，写不阻塞读**。

多版本并发控制（MVCC, multi-version concurrency control）：数据库必须可能保留一个对象的几个不同的提交版本，因为正在进行的事务可能需要看到数据库在不同的时间点的状态。

当一个事务开始时，它被赋予一个唯一的，永远增长 [8](https://github.com/Vonng/ddia/blob/master/ch7.md#user-content-fn-vii-2f825cd6de77976b378e18f94bd62fc4) 的事务 ID（`txid`）。每当事务向数据库写入任何内容时，它所写入的数据都会被标记上写入者的事务 ID。

##### 观察一致性快照的可见性规则

事务 ID 决定它对对象的可见与否。工作如下：

1. 事务开始时，数据库列出此时所有活跃的事务清单，即使之后提交了，这些事务已执行的任何写入也都会被忽略。
2. 被中止事务所执行的任何写入都将被忽略。
3. 由具有较晚事务 ID的事务所做的任何写入都被忽略，而不管这些事务是否已经提交。
4. 所有其他写入，对应用程序都是可见的。

##### 索引和快照隔离

一种选择是使索引简单地指向对象的所有版本，并且需要索引查询来过滤掉当前事务不可见的任何对象版本。当垃圾收集删除任何事务不再可见的旧对象版本时，相应的索引条目也可以被删除



#### 防止丢失更新

#### 原子写

许多数据库提供了原子更新操作，从而消除了在应用程序代码中执行`读取 - 修改 - 写入`序列的需要

```shell
UPDATE counters SET value = value + 1 WHERE key = 'foo';
```

原子操作通常通过在读取对象时，获取其上的排它锁来实现。

##### 显式锁定

如果没有原子操作，防止丢失更新的另一个选择是让应用程序显式地锁定将要更新的对象。然后应用程序可以执行读取 - 修改 - 写入序列，如果任何其他事务尝试同时读取同一个对象，则强制等待，直到第一个 **读取 - 修改 - 写入序列** 完成

```mysql
BEGIN TRANSACTION;
SELECT * FROM figures
  WHERE name = 'robot' AND game_id = 222
FOR UPDATE;

-- 检查玩家的操作是否有效，然后更新先前 SELECT 返回棋子的位置。
UPDATE figures SET position = 'c4' WHERE id = 1234;
COMMIT;
```



##### 自动检测丢失的更新

**读取 - 修改 - 写入序列**允许它们并行执行，如果事务管理器检测到丢失更新，则中止事务并强制它们重试其 **读取 - 修改 - 写入序列**。这种方法的一个优点是，数据库可以结合快照隔离高效地执行此检查。快照隔离级别，都会自动检测到丢失更新，并中止惹麻烦的事务

##### 比较并设置（CAS compare and set）

在不提供事务的数据库中，有时会发现一种原子操作:比较并设置。只有当前值从上次读取时一直未改变，才允许更新发生

```shell
-- 根据数据库的实现情况，这可能安全也可能不安全
UPDATE wiki_pages SET content = '新内容'
  WHERE id = 1234 AND content = '旧内容';
```

如果内容已经更改并且不再与 “旧内容” 相匹配，则此更新将不起作用

##### 冲突解决和复制

由于在多个节点上存在数据副本，并且在不同节点上的数据可能被并发地修改，因此需要采取一些额外的步骤来防止丢失更新。锁和 CAS 操作假定只有一个最新的数据副本。但是多主或无主复制的数据库通常允许多个写入并发执行，并异步复制到副本上，因此无法保证只有一个最新数据的副本

复制数据库中的一种常见方法是允许并发写入创建多个冲突版本的值（也称为兄弟），并使用应用代码或特殊数据结构在事实发生之后解决和合并这些版本。

原子操作可以在复制的上下文中很好地工作，尤其当它们具有可交换性时（即，可以在不同的副本上以不同的顺序应用它们，且仍然可以得到相同的结果）。例如，递增计数器或向集合添加元素是可交换的操作

最后写入胜利（LWW）的冲突解决方法很容易丢失更新

#### 写入偏斜与幻读

#### 写偏差

例子：至少有一个医生值班，两个医生分别为A,B，同时查看值班人数且同时请假，结果都成功了。

对于写偏差，我们的选择更受限制：

+ 由于涉及多个对象，单对象的原子操作不起作用
+ 自动防止写入偏差需要真正的可串行化隔离
+ 如果无法使用可串行化的隔离级别，则此情况下的次优选项可能是显式锁定事务所依赖的行

```shell
BEGIN TRANSACTION;
SELECT * FROM doctors
  WHERE on_call = TRUE
  AND shift_id = 1234 FOR UPDATE;

UPDATE doctors
  SET on_call = FALSE
  WHERE name = 'Alice'
  AND shift_id = 1234;
  
COMMIT;
```

#### 导致写偏差的幻读

1. 一个 `SELECT` 查询找出符合条件的行，并检查是否符合一些要求

2. 按照第一个查询的结果，应用代码决定是否继续。

3. 如果应用决定继续操作，就执行写入（插入、更新或删除），并提交事务。

   ```
   换句话说，如果在提交写入后，重复执行一次步骤 1 的 SELECT 查询，将会得到不同的结果。因为写入改变了符合搜索条件的行集。
   锁定步骤 1 中的行（SELECT FOR UPDATE）来使事务安全并避免写入偏差。
   ```
   
   一个事务中的写入改变另一个事务的搜索查询的结果，被称为 **幻读**【3】。快照隔离避免了只读查询中幻读

##### 物化冲突

如果幻读的问题是没有对象可以加锁，也许可以人为地在数据库中引入一个锁对象？

##### 可串行化

+ 真的串行化处理

+ 在存储过程中封装事务
  一个事务不会跨越多个请求。一个新的 HTTP 请求开始一个新的事务。**存储过程与内存存储**，使得在单个线程上执行所有事务变得可行。由于不需要等待 I/O，且避免了并发控制机制的开销，它们可以在单个线程上实现相当好的吞吐量。

  ##### 分区

  对于需要访问多个分区的任何事务，数据库必须在触及的所有分区之间协调事务。存储过程需要跨越所有分区锁定执行，以确保整个系统的可串行性。

  在特定约束条件下，真的串行执行事务，已经成为一种实现可串行化隔离等级的可行办法。

  - 每个事务都必须小而快，只要有一个缓慢的事务，就会拖慢所有事务处理。
  - 仅限于活跃数据集可以放入内存的情况。很少访问的数据可能会被移动到磁盘，但如果需要在单线程执行的事务中访问，系统就会变得非常慢 [12](https://github.com/Vonng/ddia/blob/master/ch7.md#user-content-fn-x-2f825cd6de77976b378e18f94bd62fc4)。
  - 写入吞吐量必须低到能在单个 CPU 核上处理，如若不然，事务需要能划分至单个分区，且不需要跨分区协调。
  - 跨分区事务是可能的，但是它们能被使用的程度有很大的限制

+ 两阶段锁定（2PL，two-phase locking）

  只要没有写入，就允许多个事务同时读取同一个对象。但对象只要有写入（修改或删除），就需要 **独占访问（exclusive access）** 权限

  写入不仅会阻塞其他写入，也会阻塞读，反之亦然。快照隔离使得 **读不阻塞写，写也不阻塞读**。

  ##### 实现两阶段锁

  读与写的阻塞是通过为数据库中每个对象添加锁来实现的。锁可以处于 **共享模式（shared mode）** 或 **独占模式（exclusive mode）**。锁使用如下：

  + 读事务优先加共享模式。允许多个事务同事持有共享模式
  + 若事务要写入一个对象，它必须首先以独占模式获取该锁。没有其他事务可以同时持有锁（无论是共享模式还是独占模式），所以如果对象上存在任何锁，该事务必须等待
  + 如果事务先读取再写入对象，则它可能会将其共享锁升级为独占锁

  两阶段锁的性能：

  ​	基于锁实现的读已提交隔离级别可能发生死锁。当事务由于死锁而被中止并被重试时，它需要从头重做它的工作。如果死锁很频繁，这可能意味着巨大的浪费

  ##### 谓词锁

  它属于所有符合某些搜索条件的对象：

  ```shell
  SELECT * FROM bookings
  WHERE room_id = 123 AND
        end_time > '2018-01-01 12:00' AND
        start_time < '2018-01-01 13:00';
  ```

  ##### 索引范围锁（**next-key locking**）

  通过使谓词匹配到一个更大的集合来简化谓词锁是安全的。

  ##### 悲观和乐观并发控制

  两阶段锁是一种所谓的 **悲观并发控制机制（pessimistic）** ：它是基于这样的原则：如果有事情可能出错（如另一个事务所持有的锁所表示的），最好等到情况安全后再做任何事情

  ##### 基于过时前提的决策

  有两种情况需要考虑：

  - 检测对旧 MVCC 对象版本的读取（读之前存在未提交的写入）
  - 检测影响先前读取的写入（读之后发生写入）

  ##### 检测旧MVCC读取

  当一个事务从 MVCC 数据库中的一致快照读时，它将忽略取快照时尚未提交的任何其他事务所做的写入。为了防止这种异常，数据库需要跟踪一个事务由于 MVCC 可见性规则而忽略另一个事务的写入。当事务想要提交时，数据库检查是否有任何被忽略的写入现在已经被提交。如果是这样，事务必须中止。

##### 	 检测影响之前读取的写入

##### 	可串行化快照隔离的性能

与两阶段锁定相比，可串行化快照隔离的最大优点是一个事务不需要阻塞等待另一个事务所持有的锁。就像在快照隔离下一样，写不会阻塞读，反之亦然。这种设计原则使得查询延迟更可预测，变量更少。特别是，只读查询可以运行在一致快照上，而不需要任何锁定，这对于读取繁重的工作负载非常有吸引力。