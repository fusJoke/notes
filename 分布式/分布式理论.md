## cap理论，base理论

大规模可扩放的网络服务时候会遇到三个特性：强一致性(consistency)、可用性(Availability)、分区容错(partition-tolerance)

即更新操作成功并返回客户端，所有节点在同一时间的数据完全一致。

分区容错：对外看是一个整体，不能由于分布式系统内部的某个节点挂掉了，而对外系统对外异常。所以，分布式系统而言是一定要保证分区容错性。

强一致性：一个分布式系统中各个节点之间及时同步数据。在数据同步过程中，是不能对外服务的，不然造成数据不一致。所以强一致性和可用性是不能同时满足的

可用性表示，一个分布式系统对外要保证可用。 

### base理论

1. BA：basically Available， 基本可用，表示可以允许一定很程度的不可用，比如由于系统故障，请求事件变长，或者由于系统故障导致部分非核心功能不可用，
2. s：soft state，表示分布式系统可以处于一种中间状态，比如数据正在同步
3. e：eventually consistent，表示最终一致性，不要求分布式系统实时达到一致，允许经过一段时间在达成一致，在达成一致过程中，系统也是可用的。



### 数据一致性模型

1. 强一致性：当更新操作完成之后，任何多后续进程访问都会返回最新更新过的值。
2. 弱一致性：系统在数据写入成功之后，不承诺多久可以读到最新写入的值。读到最新某一操作对系统数据更新需要一段时间，我们称这段时间为”不一致性窗口“
3. 最终一致性：强调是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。
4. 因果一致性：要求因果关系的操作顺序得到保证，非因果关系的操作顺序则无所谓
5. 会话一致性：将对系统数据的访问过程框定在一个会话中，约定了系统能够保证在同一个有效的会话中实现”读已之所写“的一致性。



## 分布式id方案

+ uuid

  ```
  1. 当前时间和时间  时间戳
  2. 时钟序列。 计数器
  3. 全局唯一的iEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得
  
  优点：代码简单，性能好。保证唯一
  缺点：
  		每次生成的id都是无序，而且不全是数字，无法保证递增
  		uuid生成的是字符串，字符串存储性能差，查找效率慢。
  		长度过长，不适用与存储，耗费数据库性能
  ```

+ 数据库自增id

  ```
  单机模式
  优点：
  	实现简单，依靠数据库即可，成本小。
  	id数字化，单调自增，满足数据库存储和查询性能。
  	具有一定业务的可读性。
  缺点：
  	强依赖性，存在单点问题
  	
  数据库高可用：多主模式做负载，基于序列的起始值的步长设置，不同的初始值。比如A数据库单数，B数据库双数。
  优点：
  	解决了id生成的单点问题，同时均衡了复制
  缺点：
  	系统扩容困难：系统定义好步长之后，增加机器之后调整步长困难。 
  	
  ```

  

+ 基于redis、mongodb、zk等中间件生成

+ 雪花算法

  ```
  生成64bit的整型数字
  第一位符号位为0，41时间戳，10位workId, 12位序列号
  优点：
  	每个毫秒值包含的id值很多，不够可以变动位数来增加，性能佳
  	时间戳值在高位，中间是固定的机器码，自增序列在地位，整个id都是趋势递增
  缺点：
  	强依赖于机器时钟，如果时钟回拨，会导致重复的id生成。此算法会抛出异常，阻止id生成。
  ```

  

## 分布式缓存寻址算法

+ hash算法：根据key进行hash函数运算，结果对分片数取模，确定分片。

  扩展分片和减少分片，所有数据都需要重新分片和存储。

+ 一致性hash：将整个hash值的区间组织成一个闭合的圆环。计算每台服务器的hash值，映射到圆环中。使用相同的hash算法计算数据的hash值，映射到圆环，顺时针寻找。第一个就是服务器的数据存储的服务器

  存在hash环倾斜的问题，可以通过虚拟节点解决

+ hash slot：讲数据与服务器隔离开，数据与slot映射，slot与服务器映射，数据进行hash决定存放的slot新增及删除节点时，将slot进行迁移即可

  

## 分布式session有什么方案

负载均衡算法下，请求会被分到不同的节点，导致本地session不可用。

把session放到redis中存储，需要多访问一次redis。

+ 实现了session共享
+ 可以水平扩展
+ 服务器重启session不丢失



## 分布式事务解决方案

XA规范：分布式事务规范，定义分布式事务模型。

四类角色：事务管理(协调者TM)、资源管理者(参与者RM)， 应用程序AP，通信资源管理器CRM

全局事务：一个横跨多个数据库事务，要么全部提交，要么全部回滚。



TCC补偿事务：try，confirm， cancel



## 分布式锁

锁可以用一个变量来表示。变量值为0时，表示没有线程获取锁。变量值为1时，表示有线程获取锁。**加锁时判断锁变量的值，根据锁变量值来判断能否加锁成功；释放锁时需要把锁变量值设置为0，表明客户端不再持有锁**。

1. 单节点redis实现分布式锁

   加锁的操作包含三个操作(读取锁变量、判断锁变量值以及把锁变量值设置为1)。可使用lua脚本和redis单命令操作。

   redis单命令操作：

   + SETNX和DEL命令组合来实现加锁和释放锁。

   + 并且给锁变量设置一个过期时间。解决有客户端持锁后异常，然后无法释放锁

   + 加锁时客户端给锁变量设置成一个唯一值。

     ```
     //nx表示不存在才设置，ex和px过期时间 
     SET key value [EX seconds | PX milliseconds]  [NX]
     ```

   + 释放锁(释放锁操作的逻辑也包含了读取锁变量、判断值、删除锁变量)]

     使用lua脚本保证原子性



## 负载均衡策略

1. 轮询

2. 加权轮询

3. 随机法

4. 加权随机

5. 源地址hash

   客户端ip进行哈希函数计算得到一个值，对这个值进行取模得到一个序号。这个序号就是要访问的服务器序号

6. 最小连接数

   

   

## 集群，分布式，微服务概念

主从，分布式和集群有什么区别

集群

+ 单机：一个系统业务量很小的时，所有的代码都放在一个项目中，然后这个项目部署在一台服务器上就好了
+ 集群：单机处理到达瓶颈的时候，你就把单机复制几份，这样就构成了一个“集群”。集群中每台服务器就叫做这个集群的一个“节点”，所有节点构成了一个集群。每个节点都提供相同的服务
+ 集群的负载均衡服务器：根据当前所有节点的负载情况，决定将这个请求交给哪个节点处理

分布式

+ 按照业务功能，拆分成一个个独立的子系统，在分布式结构中，每个子系统就被称为“服务”