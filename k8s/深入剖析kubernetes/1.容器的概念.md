进程：一旦“程序”被执行起来，它就从磁盘上的二进制文件，变成了计算机内存中的数据、寄存器里的值、堆栈中的指令、被打开的文件，以及各种设备的状态信息的一个集合。

**容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”**

**namespace机制**：隔离	

创建容器进程时，指定进程所需要启用的namespace参数。容器就只可见当前 Namespace 所限定的资源、文件、设备、状态，或者配置。而对于宿主机以及其他不相关的程序，它就完全看不到了。**Linux 操作系统还提供了 Mount、UTS、IPC、Network 和 User 这些 Namespace**

**容器只是一种特殊的进程**，多个容器之间使用的还是同一个宿主机的操作系统内核。

其次，在 Linux 内核中，有很多资源和对象是不能被 Namespace 化的，最典型的例子就是：时间。

**cgroups**：限制

**Linux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等**

**容器是一个“单进程”模型**：希望容器和应用能够**同生命周期**

在生产环境中，这个问题必须进行修正，否则应用程序在容器里读取到的 CPU 核数、可用内存等信息都是宿主机上的数据，这会给应用的运行带来非常大的困惑和风险。

top 是从 /prof/stats 目录下获取数据，所以道理上来讲，容器不挂载宿主机的该目录就可以了。lxcfs就是来实现这个功能的，做法是把宿主机的 /var/lib/lxcfs/proc/memoinfo 文件挂载到Docker容器的/proc/meminfo位置后。容器中进程读取相应文件内容时，LXCFS的FUSE实现会从容器对应的Cgroup中读取正确的内存限制。从而使得应用获得正确的资源约束设定。





## 镜像

**rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像**

同一台机器上的所有容器，都共享宿主机操作系统的内核。

只有在“挂载”操作发送之后，进程的视图才会被改变。而在此之前，新创建的容器会直接继承宿主机的各个挂载点。创建新进程时，除了声明要启用 Mount Namespace 之外，我们还可以告诉容器进程，有哪些目录需要重新挂载

**Mount Namespace 的特点：它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效**

**挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。**

**rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像**



联合文件系统：Union File System 也叫 UnionFS，最主要的功能是将多个不同位置的目录联合挂载（union mount）到同一个目录下。

上面的读写层通常也称为容器层，下面的只读层称为镜像层，所有的增删查改操作都只会作用在容器层，相同的文件上层会覆盖掉下层。知道这一点，就不难理解镜像文件的修改，比如修改一个文件的时候，首先会从上到下查找有没有这个文件，找到，就复制到容器层中，修改，修改的结果就会作用到下层的文件，这种方式也被称为copy-on-write





## Docker容器

 CMD，意思是 Dockerfile 指定 python app.py 为这个容器的进程。

Docker 会为你提供一个隐含的 ENTRYPOINT，即：/bin/sh -c

**Docker 容器的启动进程为 ENTRYPOINT**



### docker exec 是怎么做到进入容器里的呢？

查看宿主机的 proc 文件，看到这个 25686 进程的所有 Namespace 对应的文件。一个进程的每种 Linux Namespace，都在它对应的 /proc/[进程号]/ns 下有一个对应的虚拟文件，并且链接到一个真实的 Namespace 文件上。

**一个进程，可以选择加入到某个进程已有的 Namespace 当中，从而达到“进入”这个进程所在容器的目的，这正是 docker exec 的实现原理**



## volume机制

**允许你将宿主机上指定的目录或者文件，挂载到容器里面进行读取和修改操作。**

docker如何实现？





## linux容器

1. 一组联合挂载在 /var/lib/docker/aufs/mnt 上的 rootfs，这一部分我们称为“容器镜像”（Container Image），是容器的静态视图；
2. 一个由 Namespace+Cgroups 构成的隔离环境，这一部分我们称为“容器运行时”（Container Runtime），是容器的动态视图。

### k8s要解决的问题

**在 Kubernetes 项目中，kubelet 主要负责同容器运行时（比如 Docker 项目）打交道**

```
git rebase -i HEAD~3
```

