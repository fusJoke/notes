## 什么是缓存

缓存，是一种存储数据的组件，它的作用是让对数据的请求更快地返回。



### 缓冲和缓冲区

**缓冲区则是一块临时存储数据的区域，这些数据后面会被传输到其他设备上**

我们将数据写入磁盘时并不是直接刷盘，而是写到一块缓冲区里面，内核会标识这个缓冲区为脏。当经过一定时间或者脏缓冲区比例到达一定阈值时，由单独的线程把脏块刷新到硬盘上



### 缓存分类

在我们日常开发中，常见的缓存主要就是**静态缓存、分布式缓存和热点本地缓存**这三种。

**缓存比较适合于读多写少的业务场景，并且数据最好带有一定的热点属性**

**其次，缓存会给整体系统带来复杂度，并且会有数据不一致的风险**

**再次，之前提到缓存通常使用内存作为存储介质，但是内存并不是无限的**



### 缓存的读写策略



**读策略的步骤是：**

- 从缓存中读取数据；
- 如果缓存命中，则直接返回数据；
- 如果缓存不命中，则从数据库中查询数据；
- 查询到数据后，将数据写入到缓存中，并且返回给用户。

**写策略的步骤是：**

- 更新数据库中的记录；
- 删除缓存记录。

1. 一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；

2. 另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快地过期，对业务的影响也是可以接受。

### Read/Write Through（读穿 / 写穿）策略

<img src="/Users/wangfusheng/Documents/notes/架构设计/高并发系统设计/.assets/image-20221225094554395.png" alt="image-20221225094554395" style="zoom:50%;" /> 

### Write Back（写回）策略

<img src="/Users/wangfusheng/Documents/notes/架构设计/高并发系统设计/.assets/image-20221225094906109.png" alt="image-20221225094906109" style="zoom:50%;" /> 





### 缓存穿透

指从缓存中没有查到数据，而不得不从后端系统

**回种空值以及使用布隆过滤器**

1. 它在判断元素是否在集合中时是有一定错误几率的，比如它会把不是集合中的元素判断为处在集合中；

2. 不支持删除元素。

**那么我是怎么解决这个问题的呢？**我会让数组中不再只有 0 和 1 两个值，而是存储一个计数。比如如果 A 和 B 同时命中了一个数组的索引，那么这个位置的值就是 2，如果 A 被删除了就把这个值从 2 改为 1。这个方案中的数组不再存储 bit 位，而是存储数值，也就会增加空间的消耗。**所以，你要依据业务场景来选择是否能够使用布隆过滤器，**比如像是注册用户的场景下，因为用户删除的情况基本不存在，所以还是可以使用布隆过滤器来解决缓存穿透的问题的。



### 缓存击穿

1. 在代码中，控制在某一个热点缓存项失效之后启动一个后台线程，穿透到数据库，将数据加载到缓存中，在缓存未加载之前，所有访问这个缓存的请求都不再穿透而直接返回。

2. 通过在 Memcached 或者 Redis 中设置分布式锁，只有获取到锁的请求才能够穿透到数据库。
