1. 什么是资源
   资源可以是硬件设备或是一组信息。
   
   1. 可抢占资源：可从拥有它的进程抢占不会产生任何副作用
   2. 不可抢占资源：在不引起相关计算失败的情况下，无法把它从占有的进程出抢占过来
   
2. 资源的事件顺序
   1）请求资源
   2）使用资源
   3）释放资源
   一个进程请求失败的时候，进程会处于一个小循环：请求资源，休眠，在请求。

3. 死锁
   如果一个**进程集合**中 的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁。

4. 资源死锁的条件
   1)互斥条件。   2)占有和等待条件。  3)不可抢占条件。  4)环路等待条件。
   <img src="/Users/wangfusheng/Library/Application Support/typora-user-images/image-20200918095245732.png" alt="image-20200918095245732" style="zoom:50%;" />

5. 死锁检测和死锁恢复
   1)每种类型一个资源的死锁检测
           一个系统A到G共7个进程，R到W共6中资源
          <img src="/Users/wangfusheng/Library/Application Support/typora-user-images/image-20200918140455132.png" alt="image-20200918140455132" style="zoom:50%;" />

   ​		然后使用算法进行检查，
   ​			①对每个节点N，N作为起始点执行5个步骤。
   ​			②L为空表，忽略有向边。
   ​			③当前节点添加至L尾部，并检测节点是否出现两次。
   ​			④检测是否存在没有标记的从该节点出发的有向边。如果存在执行第五步；不存在，执行第六步
   ​			⑤随机选取一条没有标记的从该节点出发，标记它。然后顺着这条有向边找到新的当前节点。返回第三步
   ​			⑥如果这个节点是起始节点，那么表名不存在任何的环。

   2)每种类型多个资源的死锁检测
   		基于矩阵的算法来检测p1到pn这n个进程中的死锁。假设资源的类型为m，E1代表资源类型1，E2资源类型2，Ei代表资源类型i；E是现有资源向量，代表每种已经存在的资源总数，
   <img src="/Users/wangfusheng/Library/Application Support/typora-user-images/image-20200918155448288.png" alt="image-20200918155448288" style="zoom:50%;" />

   ​			死锁检测算法就是基于向量的比较。向量A和向量B之间的关系为A<=B以表明A的每一个分量要么等于要么小于和B向量相对应的分量。
   ​				①寻找一个没有标记的进程Pi,对于它而言R矩阵的第i行向量小于或等于A。
   ​				②如果找到这样一个进程，那么将C矩阵的第i行向量加到A中，标记该进程，并转到第一步。
   ​				③没有这样的进程，那么算法终止。

    3）从死锁中恢复
   			①利用抢占恢复。在不通知原程序的情况下，讲某一资源从一个进程强行取走给另一个进程使用。
   			②利用回滚恢复。
   			③通过杀死进程来恢复。

   4）避免死锁
   	<img src="/Users/wangfusheng/Library/Application Support/typora-user-images/image-20200918205619624.png" alt="image-20200918205619624" style="zoom:50%;" />

   ​	安全状态和不安全状态
   ​	就算进程最大加大对资源的需求，也存在一种调度的方式让每个进程都运行完毕，这种就是安全状态。
   ​	

   5）两阶段加锁
   		第一节阶段试图对所有需要的记录进行加锁，如果第一阶段加锁成功，就开始第二阶段，完成更新释放锁。

   6）通信死锁。
   		进程A向进程B发送请求信息，然后阻塞直至B回复。假设请求信息丢失，A讲阻塞以等待回复，而B会阻塞等待一个向其命令请求。因此发送死锁。

   7)  活锁
   	进程意识到自己无法获取到所请求的资源，主动释放自己已经获得的锁。但是同时有其他的进程也是这么做。