## 3.2 程序编码

### 3.2.1 机器级代码

汇编代码对处理器的状态是可见：

+ 程序计数器，下一条指令在存储器的地址。
+ 整数寄存器文件包含8个被命名的位置，分别存储32位的值。这些寄存器可以存储地址或者整数数据。有的寄存器用来记录程序的状态，保存临时数据，局部变量。
+ 条件寄存器保存最近执行的算术指令的状态信息。
+ 浮点寄存器文件包含8个位置，用来存放浮点数据。

汇编代码只是将存储器看成一个很大，按字节排序的数组。

程序存储器包含程序的目标代码，操作系统需要的一些信息，用来管理过程调用和返回运行时栈，以及用户分配的存储器块

### 3.2.2 

机器实际执行的程序只是对一系列指令进行编码的字节序列。

## 3.3 数据格式

字word表示16位数据类型。32位为双字。

### 3.4 访问信息

X86-64的cpu包含一组16个64位的通用寄存器。通用寄存器用来存储整数数据和指针。

<img src="/Users/wangfusheng/Documents/notes/操作系统/csapp/.assets/image-20221009141918987-5296360.png" alt="image-20221009141918987" style="zoom:67%;" /> 

### 3.4.1 操作数指示符

多数指令有一到多个操作数（operand），指示出使用的源数据值以及结果放置的目的位置。
源数据值可以常数、寄存器读、内存中读取。
结果可以放置在寄存器或者内存

操作数的类型：

+ 立即数，表示常数值
+ 寄存器，某个寄存器的内容
+ 内存引用

<img src="/Users/wangfusheng/Documents/notes/操作系统/csapp/.assets/image-20221009145338174.png" alt="image-20221009145338174" style="zoom:50%;" /> 

### 3.4.2 数据传输指令

使用最频繁的指令是mov类：将数据复制到另一个位置的指令。

<img src="/Users/wangfusheng/Documents/notes/操作系统/csapp/.assets/image-20221009145959630-5298801.png" alt="image-20221009145959630" style="zoom:50%;" /> 

源操作数指定一个立即数；目的操作数指定一个位置。

<img src="/Users/wangfusheng/Documents/notes/操作系统/csapp/.assets/image-20221009152112081.png" alt="image-20221009152112081" style="zoom: 50%;" />   

### 3.4.4 压入和弹出栈数据

<img src="/Users/wangfusheng/Documents/notes/操作系统/csapp/.assets/image-20221009155848588-5302329.png" alt="image-20221009155848588" style="zoom:50%;" /> 

<img src="/Users/wangfusheng/Documents/notes/操作系统/csapp/.assets/image-20221009160327348.png" alt="image-20221009160327348" style="zoom: 50%;" /> 

###  3.5 算术和逻辑操作

<img src="/Users/wangfusheng/Documents/notes/操作系统/csapp/.assets/image-20221009162943757.png" alt="image-20221009162943757" style="zoom:50%;" /> 

### 3.5.1 加载有效地址

第一组的leaq（load effective address），从内存读数据到寄存器，但实际上没有引用内存。

<img src="/Users/wangfusheng/Documents/notes/操作系统/csapp/.assets/image-20221009164041392.png" alt="image-20221009164041392" style="zoom:50%;" /> 

### 3.5.2 一元和二元操作

第二组的是一元操作，即是源又是目的。这个操作数既可以是内存也可以是寄存器。

第三组的是二元操作，第二个操作数即是源又是目的。

### 3.5.3 位移操作

第四组的是位移操作，先给出位移量，在给出位移数。



### 3.5.5 特殊的算术操作

<img src="/Users/wangfusheng/Documents/notes/操作系统/csapp/.assets/image-20221009204552529.png" alt="image-20221009204552529" style="zoom:50%;" /> 



## 3.6 控制

用jump指令可以改变一组机器代码指令的执行顺序。

### 3.6.1 条件码

单个位的条件码（condtion code）寄存器，它们描述了最近的算术或逻辑操作属性。

+ CF 进位标志。最近的操作使得最高位产生的进位。
+ ZF 零标志。最近的操作得出的结果为0
+ SF 符号标志。最近的操作得到的结果为负数
+ OF 溢出标志。 最近的操作导致一个补码溢出--正溢或者负溢出

<img src="/Users/wangfusheng/Documents/notes/操作系统/csapp/.assets/image-20221009215911276.png" alt="image-20221009215911276" style="zoom:50%;" /> 

### 3.6.2 访问条件码

1. 根据条件码的组合将一个字节设置为0或1；set指令，setl（set less）小于时设置；setb低于时设置（set below）
2. 可以跳转到程序的某个其他的部分。
3. 可以有条件的传送数据。

<img src="/Users/wangfusheng/Documents/notes/操作系统/csapp/.assets/image-20221009221619656.png" alt="image-20221009221619656" style="zoom:50%;" /> 

### 3.6.3 跳转指令

jump指令是无条件跳转的。它可以直接跳转，即跳转目标是作为指令的一部分编码。也可以间接跳转，即跳转目标是从寄存器或者内存中读取的。间接跳转的写法是*加操作数指示符。



### 3.6.4 跳转指令的编码

1. 跳转指令最常用的编码是pc-relative，就是将目标指令的地址与之后的指令的地址的差作为编码。

2. 绝对地址：用4个字节直接指向地址



### 3.6.5 用条件控制来实现条件分支

<img src="/Users/wangfusheng/Documents/notes/操作系统/csapp/.assets/image-20221010141400287.png" alt="image-20221010141400287" style="zoom:50%;" /> 

### 3.6.6 使用条件传送来实现条件分支

<img src="/Users/wangfusheng/Documents/notes/操作系统/csapp/.assets/image-20221010150255435.png" alt="image-20221010150255435" style="zoom: 33%;" />  

### 3.6.7 循环

条件测试和跳转组合来实现循环的效果。



### 3.6.8 switch

switch根据一个整数索引值进行多重分支。而且通过跳转表这种数据结构使得实现更加高效。跳转表是一个数组，表项i是一个代码段的地址。

<img src="/Users/wangfusheng/Documents/notes/操作系统/csapp/.assets/image-20221010220009442.png" alt="image-20221010220009442" style="zoom:50%;" /> 

### 3.7 过程

封装代码的方式，用一组指定的参数和一个可选的返回值来某个功能。

假设过程P调用过程Q，Q执行后返回p：

​	传递控制，进入过程Q的时候，程序计数器必须被设置为Q代码的起始地址，然后返回时，要把程序计数器设置为p调用Q后面那条指令的地址。

​	传递数据，P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值。

​	分配和释放内存，在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些空间。



### 3.7.1 运行栈

C语言过程调用的机制：栈数据结构提供后进先出的内存管理原则。

<img src="/Users/wangfusheng/Documents/notes/操作系统/csapp/.assets/image-20221010222117519.png" alt="image-20221010222117519" style="zoom:50%;" /> 

当x86-64过程需要的存储空间超过寄存器能够存放的大小时，就会在栈上面分配空间。这个部分称为过程的栈帧（stack fram）。

当过程P调用过程Q，会把返回地址压入栈中。

大多数的栈帧都是定长的，在过程开始的时候就分配好了。



### 3.7.2 转移控制

将控制从函数P转移到函数Q只需要简单地把程序计数器PC设置Q代码的起始位置。从Q返回时，处理器必须记录好它需要继续P执行代码的位置。

这个信息是指令callQ调用过程Q记录的：把地址A压入栈中并将PC设置为Q的起始地址。对应的指令ret会从栈中弹出地址A，并把PC设置为A。

<img src="/Users/wangfusheng/Documents/notes/操作系统/csapp/.assets/image-20221010223321574.png" alt="image-20221010223321574" style="zoom: 50%;" /> 



### 3.7.3 数据传送

大部分过程间的数据传送是通过寄存器实现的。

​         

### 3.7.4 栈上的局部存储

+ 寄存器不足够存放所有的内存
+ 对一个局部变量使用地址运算符‘&’
+ 某些局部变量数组或结构，因此必须能够通过数组或结构引用被访问到



### 3.7.5 寄存器中的局部存储空间

寄存器组是唯一被所有过程共享的资源。

%rbx，$rbp和%r12~%r15被划分为被调用者保存寄存器。

P调用Q，会将P的寄存器状态压入Q的栈帧。

### 3.7.6 递归调用

栈规则提供一种机制，每次函数调用都有它私有的状态信息（保存的返回位置和被调用者保存寄存器的值）存储空间。

## 3.8 数组分配和访问

### 3.8.1 基本原则

对于数据类型T和整型常数N，声明如下：T A[N]

分配一个L * N字节的连续内存区域，L是T类型的大小。标识符A指向数组开头的指针。

### 3.8.2 指针运算

​	<img src="/Users/wangfusheng/Documents/notes/操作系统/csapp/.assets/image-20221011232317987.png" alt="image-20221011232317987" style="zoom:50%;" /> 

### 3.8.3 嵌套数组



### 3.8.4 定长数组



### 3.8.5 变长数组



## 3.9 异质的数据结构

### 3.9.3 数据对齐

对齐原则则是任何k字节的基本对象的地址必须是k的倍数

对于包含结构的代码，编译器在字段的分配中插入间隙，以保证每个结构元素它的对齐要求。

## 3.10 在机器级程序将控制与数据结合起来



### 3.10.1 指针

+ 每个指针都对应一个类型
+ 每个指针都有一个值
+ 指针通过&创建
+ 指针从一种类型强制转换成另一种类型，但不改变的值。
+ 指针也可以指向函数。



### 3.10.3 内存越界和缓冲区溢出

缓冲区溢出：比如字符串的长度超出了数组分配的空间。

### 3.10.4 对抗缓存区溢出攻击

1.栈随机化

程序开始在栈上分配一段0-n字节之间的随机大小的空间，但是不使用。这段空间会导致栈的位置每次运行都不同。

2.栈破坏检测

<img src="/Users/wangfusheng/Documents/notes/操作系统/csapp/.assets/image-20221012214920541.png" alt="image-20221012214920541" style="zoom: 50%;" /> 

3.限制可执行代码区域



### 3.10.5 支持变长栈帧

<img src="/Users/wangfusheng/Documents/notes/操作系统/csapp/.assets/image-20221012220612440.png" alt="image-20221012220612440" style="zoom:50%;" /> 



## 3.11 浮点代码

avx浮点体系结构允许数据存储在16个YMM寄存器中，%ymm~%ymm15

每个ymm寄存器都是256位。

当对标量数据操作时，这些寄存器只保存浮点数，只使用低32位或64位。

<img src="/Users/wangfusheng/Documents/notes/操作系统/csapp/.assets/image-20221012221352786.png" alt="image-20221012221352786" style="zoom:50%;" /> 

### 3.11.1 浮点传送和转换操作

<img src="/Users/wangfusheng/Documents/notes/操作系统/csapp/.assets/image-20221012222457850.png" alt="image-20221012222457850" style="zoom:50%;" /> 

### 3.11.2 过程中的浮点代码

xmm寄存器用来向函数传递浮点参数，以及从函数返回浮点值。

+ xmm寄存器%xmm0~%xmm7最多可以传递8个浮点参数。
+ 函数使用寄存器%xmm0来返回浮点值。
+ 所有的xmm寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器人一个。

### 3.11.3 浮点运算操作

字word表示16位数据类型。32位为双字。
