# 如何理解单一职责原则（SRP）？

单一职责原则的英文是 Single Responsibility Principle。

A class or module should have a single reponsibility

一个类或者模块只负责完成一个职责（或者功能）。

评价一个类的职责是否足够单一，我们并没有一个非常明确的、可以量化的标准，可以说，这是件非常主观、仁者见仁智者见智的事情。实际上，在真正的软件开发中，我们也没必要过于未雨绸缪，过度设计。所以，**我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构**



下面这几条判断原则，比起很主观地去思考类是否职责单一，要更有指导意义、更

具有可执行性：

+ 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑

  对类进行拆分

+ 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，

  我们就需要考虑对类进行拆分；

+ 私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供

  更多的类使用，从而提高代码的复用性；

+ 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的

  Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；

实际上，我也可以给你一个凑活能用、比较宽泛的、可量化的标准，那就是一个类的代码行数最好不能超过 200 行，函数个数及属性个数都最好不要超过 10 个

### **类的职责是否设计得越单一越好？**

虽然经过拆分之后，Serializer 类和 Deserializer 类的职责更加单一了，但也随之带来了新的问题。如果我们修改了协议的格式，数据标识从“UEUEUE”改为“DFDFDF”，或者序列化方式从 JSON 改为了 XML，那 Serializer 类和 Deserializer 类都需要做相应的修改，代码的内聚性显然没有原来 Serialization 高了。而且，如果我们仅仅对 Serializer 类做了协议修改，而忘记了修改 Deserializer 类的代码，那就会导致序列化、反序列化不匹配，程序运行出错，也就是说，拆分之后，代码的可维护性变差了。